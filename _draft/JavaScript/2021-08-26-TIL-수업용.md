---
title: "함수 vs 생성자 함수 vs class and prototype"
categories: 
  - javascript
tags: 
    - 함수
    - 생성자함수
    - 프로토타입
    - 객체
    - 자바스크립트 이론
    - 클래스용 내용정리
toc: true
toc_sticky: true
comments:  true
---


들어가기에앞서 자바스크립트는 원시타입값들을 제외한 모든것이 객체입니다. 복습차원에서 원시타입은 총 6가지가 있는데
- string
- number
- undefined
- boolean
- null
- Symbol()

이 여섯가지를 제외한 함수, 객체리터럴, 생성자함수, 클래스, 배열 등은 모두 객체로 취급됩니다. 자바스크립트의 모든 객체는 `[[Prototype]]` 이라는 내부 슬롯을 가지고 이 내부 슬롯에 저장되는 프로토타입은 객체를 생성하는 방식에 의해서 결정됩니다.

```js
const obj = { name: '홍길동' }
function Person () { this.name = '홍길동' }
console.dir(obj) // 객체 리터럴에 의해서 생성된 객체
console.dir(new Person()) // 생성자 함수 호출에 의해서 생성된 객체
```

객체 리터럴에 의해서 생성된 객체의 프로토타입은 `Object.prototype` 이고   
생성자함수에 의해서 생성된 객체의 프로토타입은 생성자 함수의 `prototype` 프로퍼티에 바인딩 되어있는 객체입니다. 
  
해당 프로토타입은 객체가 생성되는 시점에서 결정됩니다. 일단 객체 리터럴로 생성된 객체부터 확인해보겠습니다. 

### 객체 리터럴에 의해서 생성된 객체의 프로토 타입
```js
const obj = { name: '홍길동' }
console.log(obj.constructor === Object); // true
console.log(obj)
/*
name: '홍길동'
[[Prototype]]: Object
*/
```
객체 리터럴에 의해 생성된 객체는 `Object.prototype` 을 상속받습니다. 자바스크립트는 class 문법이 기본적으로 존재하지않기때문에 프로토타입에 의해서 상속을 받아서 사용할 수 있습니다. 상속이란 부모가 갖고있는 프로퍼티나 메소드들을 모두 물려받아 사용할 수 있는걸 말합니다.
  
```js
obj.hasOwnProperty("name") // true
```
obj에 객체를 할당할때 `hasOwnProperty` 라는 메소드를 생성해 준적은 없습니다. 그러나 사용가능하죠 `hasOwnProperty` 는 해당 객체에 name 이라는 프로퍼티가 있는지 없는지 확인할 수 있는 메소드입니다. 이 메소드는 `Object.prototype` 이 갖고있고 객체 리터럴 방식으로 객체가 생성되면 `Object.prototype` 이 갖고있는 모든 프로퍼티를 상속받아 `[[Prototype]]` 에 저장됩니다.

```js
console.log(Object.prototype)
/*
    constructor: ƒ Object()
    hasOwnProperty: ƒ hasOwnProperty()
    isPrototypeOf: ƒ isPrototypeOf()
    propertyIsEnumerable: ƒ propertyIsEnumerable()
    toLocaleString: ƒ toLocaleString()
    toString: ƒ toString()
    valueOf: ƒ valueOf()
*/
```
`Object.prototype` 에는 저런 메소드들을 포함하고있는데 저걸 객체리터럴로 생성한 `obj` 에서도 동일하게 사용가능합니다. 이러한 특징으로 자바스크립트는 프로토타입 기반 언어라고 불리어집니다.
  
여기서 한가지 짚고 넘어가야할 부분은 [Object 에 대해서 MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object) 에서 확인을 해보면 상속받아 사용할 수 있는 프로퍼티들보다 더 많은 프로퍼티가 정의되어있는걸 볼 수 있습니다.

```js
console.dir(Object)
/*
    arguments: (...)
    assign: ƒ assign()
    caller: (...)
    create: ƒ create()
    defineProperties: ƒ defineProperties()
    defineProperty: ƒ defineProperty()
    entries: ƒ entries()
    freeze: ƒ freeze()
    fromEntries: ƒ fromEntries()
    getOwnPropertyDescriptor: ƒ getOwnPropertyDescriptor()
    getOwnPropertyDescriptors: ƒ getOwnPropertyDescriptors()
    getOwnPropertyNames: ƒ getOwnPropertyNames()
    getOwnPropertySymbols: ƒ getOwnPropertySymbols()
    getPrototypeOf: ƒ getPrototypeOf()
    is: ƒ is()
    isExtensible: ƒ isExtensible()
    isFrozen: ƒ isFrozen()
    isSealed: ƒ isSealed()
    keys: ƒ keys()
    length: 1
    name: "Object"
    preventExtensions: ƒ preventExtensions()
    prototype: {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
    seal: ƒ seal()
    setPrototypeOf: ƒ setPrototypeOf()
    values: ƒ values()
*/
```
이것들은 <span style="color: red">상속받아 사용할 수 없는</span> 프로퍼티들인데 바로 `prototype` 에 정의된 프로퍼티가 아니기 떄문입니다. 자바스크립트는 프로토타입기반 언어이고 상속받아 사용할 수 있으려면 `prototype` 에 정의가 되어있어야 합니다.
  
자바스크립트에는 빌트인 객체이자 전역객체들이 존재합니다. 자바스크립트에서 생성하는 모든것들은 다 객체이고 이 객체들은 다 전역객체에서 프로토타입에 정의된 메소드와 속성들을 상속받아 사용가능합니다.

```js
const name = "홍길동"
name.split("") // ["홍", "길", "동"]
console.log(name.__proto__)
```
`__proto__` 는 특정 객체의 프로토타입 객체에 접근할 수 있는 접근자 역할을 합니다. 즉 name 에 어떤 프로퍼티들이 상속되어져 있는 프로토타입에 저장된 내용들을 확인할 수 있습니다. 확인해보면 name 은 `String` 객체를 상속받고있고 `String.prototype` 에 정의된 메소드들이라면 name 에도 아무런 정의를 하지않아도 동일하게 사용가능합니다. 

> `__proto__` 는 프로토타입객체에 접근할 수 있는 접근자로 자바스크립트에 생성되는 모든 객체에 존재합니다.  

프로토타입에 정의만 되어있다면 해당 전역객체를 상속받아 사용하는 어떤 객체가 생성되더라도 사용이 가능하다는걸 확인했습니다. 그럼 한번 직접 정의해서 정말 그런지 확인해보겠습니다.

```js
const name = "홍길동"
const age = 12
String.prototype.test = function () { console.log("test") };

const name2 = "둘리"

console.log(name.test()) // test
console.log(age.test()) // TypeError
console.log(name2.test()) // test
```
확인해보면 프로토타입에 정의해준 test() 메소드가 정상적으로 상속되어졌음을 확인할 수 있습니다. 이때 age 같은경우는 에러가 발생했는데 상속받는 객체의 종류가 다르기때문입니다. 텍스트와 숫자는 다른 데이터 타입이기때문에 상속받는 객체도 다릅니다. 때문에 사용할 수 있는 메소드도 다릅니다.
숫자는 `Number.prototype` 에 정의된 메소드들을 사용할 수 있습니다.

> 전역객체가 계속해서 등장하는데 전역객체에는 빌트인 객체들이 포함되며 빌트인 객체는 `Object, String, Number, Function , Array...` 들이 있습니다. 이러한 전역객체 그리고 빌트인 객체는 코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 생성되는 특수한 객체들입니다. 때문에 객체를 생성하게되면 전역객체의 빌트인 객체가 갖고있는 프로토타입에 정의된 메소드들을 생성된 객체의 [[Prototype]] 내부 슬롯에 할당합니다.
  
