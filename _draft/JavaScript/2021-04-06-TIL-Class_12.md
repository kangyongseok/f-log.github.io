---
title: "JavaScript Class"
categories: 
  - javascript
tags: 
    - 자바스크립트
    - 자바스크립트기본
    - 기본으로돌아가서
    - 클래스
toc: true
toc_sticky: true
comments:  true
---

## 오해
- 자바스크립트의 클래스는 다른 객체지행언어의 클래스와 같지 않다.
- 자바스크립트는 클래스식별자 없이도 생성자 함수와 프로토타입으로 객체지향언어의 상속을 구현할 수 있다.
- 생성자 함수와 클래스는 비슷하지만 클래스가 좀더 엄격한 기준을 갖고있다.

## 클래스와 생성자함수의 차이
### 생성자 함수
```javascript
const Person = (function() {
    function Person(name) {
        this.name = name;
    }

    Person.prototype.sayHi = function() {
        console.log(`Hi ${this.name}`)
    };

    return Person;
}());

const me = new Person('kang');
me.sayHi(); // Hi Kang
```

### 클래스
```javascript
class Person {
    constructor(name) {
        this.name = name;
    }

    sayHi() {
        console.log(`Hi ${this.name}`)
    }
}

const me = new Person('Kang');
me.sayHi(); // Hi Kang
me.name // Kang
```
  

1. 클래스는 `new` 연산자를 통해서만 호출해야만 한다. 생성자함수는 `new` 를 붙여도 붙이지않아도 호출이 가능하지만 `new` 연산자가없을땐 일반함수로써 호출된다.
2. 클래스는 상속을 지원하는 `extends`, `super` 키워드를 제공한다.
3. 클래스는 호이스팅이 발생하지않는것처럼 동작한다. 함수선언문으로 정의된 생성자함수는 함수 호티스팅이 발생, 함수표현식으로 정의한 생서자 함수는 변수 호이스팅이 발생한다.
4. 클래스내의 모든 코드에는 암묵적으로 `strict mode` 가 지정되어 실행된다.
5. 자바스크립트의 클래스는 함수객체로 평가된다.

> 자바스크립트의 Class 는 새로운 객체생성 매커니즘이다.

## 비교
```javascript
// 생성자함수
function Person(name) {
    this.name = name;
}

// 생성자
constructor(name) {
    this.name = name;
}
```
  
```javascript
// 프로토타입 메서드
Person.prototype.sayHi = function() {
    console.log(`Hi ${this.name}`)
}


sayHi() {
    console.log(`Hi ${this.name}`)
}
```
  

```javascript
// 정적 메서드
Person.sayHello = function() {
    console.log('Hello')
}


static sayHello() {
    console.log('Hello')
}
```

## constuctor
`constuctor` 는 인스턴스를 생성하고 초기와하기위한 특수한 메서드.