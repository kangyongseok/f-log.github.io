---
title: "JavaScript Immutability"
categories: 
  - javascript
tags: 
    - 자바스크립트
    - 자바스크립트기본
    - 기본으로돌아가서
    - Immutability
    - 자바스크립트 불변성
    - 자바스크립트 객체
toc: true
toc_sticky: true
comments:  true
---

## Immutability (불변성)
불변성은 함수형 프로그래밍의 핵심 원리이며 객체가 생성된 이후 그 상태를 변경할 수 없는 상태를 의미한다.  
자바스크립트의 원시타입들은 변경불가능한 값이다.
- boolean
- null
- undefined
- number
- string

원시타입 이외의 모든 값은 객체타입이며 변경가능한 값으로 볼 수 있다.

## 예제1
```javascript
let a = "Hello";
console.log(a) // Hello

a = "world"
console.log(a) // world
```

위의 예제는 얼핏보면 a 에 값이 바뀐것같지만 내부 동작은 다르다. 처음 변수 선언에서 메모리 어딘가에 "Hello" 라는 문자열이 생성되고 a 는 "Hello" 가 생성된 메모리주소를 가르키게된다.  
이후 `a = "world"` 로 새로운 문자열을 넣어주면 새로운 메모리영역에 world 가 생성되고 a 는 world 가 있는 메모리주소를 가르키게된다.
  
즉 메모리 어딘가에 `"Hello"` 와 `"world"` 둘다 존재하고 있다고 볼 수 있다.

## 예제2
```javascript
let b = "I am developer";

let sliceText = b.slice(5, 14);
console.log(sliceText) // developer
console.log(b) // I am developer
```
여기서의 slice() 함수는 새로운 문자열을 생성하여 반환하기때문에 b 를 함수 실행 후 출력해도 저장된 문자열 그대로 출력하게된다.  
문자열으 자바스크립트의 원시타입으로 변경 불가능한 값이다. 변경되는것처럼 보이는건 단지 가르키는 메모리주소가 변경되거나 새로운 영역을 사용할 뿐이다.

## 예제3
```javascript
let arr = [];
console.log(arr.length) // 0

let arr2 = arr.push(1);
console.log(arr.length) // 1
console.log(arr2) // 1
console.log(arr) // [1]
```
예제3에서 arr 변수를 빈 배열을 갖고있는데 배열은 자바스크립트에서 객체이다. 
따라서 arr.push() 함수를 사용하면 객체 자체에 값이 변화가 발생하고 arr 을 출력해보면 1을 갖고있는 배열이 출력되는걸 볼 수 있다.

## 예제4
```javascript
let user = {
  name: 'kang',
  age: 24,
  job: {
    developer: 'frontend',
    lang: 'javascript',
  }
}

let userName = user.name;

user.name = 'Kim';
console.log(userName) // kang
console.log(user) 
/*
name: 'Kim',
  age: 24,
  job: {
    developer: 'frontend',
    lang: 'javascript',
  }
*/

userName = user.name;
console.log(userName) // Kim
```

예제4 에서 user 는 객체이기때문에 내부의 값들이 변경이 가능하다. 그러나 `userName` 이라는 변수에 `user.name` 을 할당하고 user에 name 값을 변경하게되었을때 `userName` 에는 아무런 변화가 없다.  
그렇다는건 userName 변수는 user 객체를 참조하고있는것이 아닌 user.name 이 갖고있는 kang 를 메모리에 생성하고 userName 은 이 메모리를 참조하고있기 때문이다. userName 이 변경된 user.name 값을 참조하기위해서는 재할당을 해주어야하는데 이때도 역시 기존의 kang 는 메모리상에 어딘가에 존재하고있고 Kim 이라는 새로운 문자열을 메모리에 생성하고 userName 은 그 메모리를 참조하게된다. 

## 예제5
```javascript
let obj1 = {} // 빈 객체
let obj2 = obj1 // obj1 을 참조하는 객체

obj1.value = 100;
console.log(obj1) // {value: 100}
console.log(obj2) // {value: 100}
```
