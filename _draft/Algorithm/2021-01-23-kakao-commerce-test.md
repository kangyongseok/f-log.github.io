---
title: "카카오커머스 - 프론트엔드 개발 챌린지"
categories: 
  -  Algorithm
tags: 
    - 코딩테스트
    - 카카오
    - javascript
    - 프로그래머스
    - 알고리즘풀이
    - 카카오커머스
    - 개발챌린지
    - 카카오커머스채용
toc: true
toc_sticky: true
comments:  true
---

이번에 카카오커머스에서 프론트개발자 채용을위해 프로그래머스에서 두번에 걸쳐 알고리즘과 과제테스트로 코딩테스트를 진행하는데에 응시를 하였다. 채용에있어 테스트의 난이도가 얼마나되는지 나는 얼마나 풀 수 있을지 나중에 진짜 이직하거나 다른회사에서 테스트를 볼때 내가 가능성이 있을지에대한 궁금증과 그냥 한번 지원해서 문제 풀어보는것도 재미있겠다 싶었다.  
  
이직을 생각하면서 프로그래머스에서 1단계문제들부터 조금씩 풀어 나가고 있는데 일단 이번 챌린지 난이도를 얘기하자면 생각보다 그렇게 난이도가 높다라고 생각들지는않았다. 

- 2시간의 제한시간
- 3개의 알고리즘 문제풀이

2문제는 풀었지만 그나마도 한문제는 최종 통과는 하지못했다. 테스트케이스를 추가해봐도 정상적으로 다 통과되는데 제출만하면 3개의 케이스를 제외하고는 다 실패가 떠버려서...어떤 예외의 상황을 넣어야할지 잘 감이 오지않았다.
  
마지막 문제는 시간이모자라서 풀지는 못하고 문제에 대해 이해만 하고 종료되버렸는데 문제를 이해하는데만도 시간이 꽤 필요했었던 마지막 문제이기도했다.
 
다 풀지도못하고 심지어 푼것도 제대로 통과도 못하고 난이도를 얘기할 상황은 아니긴한데....프로그래머스에있는 알고리즘 문제들을 단계를 좀 높이면서 풀다보면 충분히 해결할 수 있을문제들이지 않았을까 싶다.

## 첫번째문제
첫번째문제는 n개의 게임서버가 주어지고 각각의 게임 서버에서는 계정을 만들 수 있다. 
- 이때 한 서버당 생성가능한 계정은 총 5개까지이고
- 중복되는 계정은 생성이 불가능하다
- 만약 5개가 넘는 계정이 생성되면 제일 먼저 생성되었던 계정이 삭제된다.
- 서버의 갯수는 숫자로 주어지며 각 서버에 생성된 계정들을 하나의 배열로 결과를 제출해야한다.

```javascript
const n = 1
const id = ['1 test', '1 good', '1 kakao', '1 k']
```
뭐 대충 이런식으로 주어지는데 배열에서 맨앞에 숫자는 서버를 나타내고 뒤에 텍스트가 생성된 계정을 말한다.

실제로 리턴되야하는 배열은
```javascript
['test', 'good', 'kakao', 'k']
```

이다. 알고리즘중에 가장 기본이고 단순한 FIFO 문제인데 거기에 출력에 약간의 코드를 더해서 숫자를 뺀 아이디만 출력이 되어야하고 한서버당 5개의 아이디 제한과 서버가 n대라면 각각 서버에서 생성된 계정들을 하나의 배열로 출력해야한다는것 정도?

첫번째문제는 30분정도 걸렸던것같다.


## 두번째문제
두번째문제는 제대로 푼것같은데 테스트케이스를 나름 추가해서 한것도 다 통과했는데 제출하면 3개빼고는 죄다 실패가 떠서 이유를 모르겠는 문제이다... 아마 나중에 프로그래머스에 다시 연습풀이용으로 올라올것같은데 그때 다시 풀어봐야겠다.
  
테트리스문제였는데 블록의 종류는 높이가 1인 넓이만 존재하는 블럭만 존재한다. 테트리스인데 꽉 채워서 없애는건 아니고 그냥 블록이 몇층까지 쌓이는지를 출력하는 문제였다.

```javascript
const n = 4 // 블록을 담는 영역의 최대 넓이
const arr = [2, 3, 1] // 블록의 넓이
정답 2 // 2층의 블록이 쌓임
```

첫번째 숫자는 블록이 쌓이는 영역의 넓이를 말하고 배열은 떨어지는 블록의 넓이를 말한다. 첫번째 블록은 전체 4칸의 영역중 2칸의 영역을 차지하며 1층에 쌓이고  
두번째 블록은 전체 4칸중 3칸을 차지하는데 1층에 남은공간은 2칸뿐이라 2층으로 쌓인다.  
세번째 블록은 1층에 2칸의 영역이 남아있는데 1칸만 갖는 블록이라 1층에 안착할 수 있다.
  
따라서 최종적으로 쌓인 블록의 높이는 2가된다.
  
난 새로운 배열을 하나 만들어서 여기에 블록이 쌓이고 그 층에 남은 빈칸의 값을 넣도록 하였고 만약 다음블록이 빈칸영역보다 크다면 새로운 배열에 다시 push 를 하여 층을 쌓는다. 
만약 다음블록이 전층의 남은 빈칸보다 작거나 같다면 나머지 빈칸영역을 채우고 남은 칸수만큼 해당층에 값을 바꿔치기한다.
  
즉 블록이 쌓이면서 더 낮은층에 해당 블록이 들어갈 공간이 있다면 그 층에 넣어주고 어디에도 낄곳이 없다면 쌓이는블록의 모양을 새로운 배열에 담았고 이 배열의 length 를 리턴하도로 하였다. 
  
생각한대로 코드도짰고 테스트케이스도 이것저것 추가해가면서 통과시켜봤는데 제출했을땐 절반도 통과를 못했다. 아마 두번째문제에서 해결해야할점은 예외 상황에 대한 캐치와 그에따른 코드 작성이 아니었을까 싶다


## 세번째문제
세번째문제는 ... 뭐 설명을 잘 못하겠다 문제 이해하는데만도 시간이 좀 필요했었으니까 n 명의 학생들이 암기카드를 서로 돌려가면서 암기를 하게되는데 여기서 주어지는 값은 하나의 배열만 주어진다.

```javascript
const next_student = [5, 7, 9, 0, 0, 11, 13, 8, 2, 1, 3, 4, 6]
```
뭐 대충 위와같이 주어졌던것같은데 배열의 갯수가 n 명의 학생들이고 각각의 index 와 배열의 숫자는 학생의 번호 라고 볼 수 있다.  
### #1
- 0번째 인덱스 여기서는 1번 학생이 5번학생에게 암기카드를 전달
- 5번학생은 배열의 5번째 즉 0번째 학생에게 전달한건데 배열에 0은 아무에게도 전달하지 않은것
- 즉 1번학생에게서 출발한 암기카드는 5번에게 전달되고 더이상 전달되지않음
- 1번학생이 전달한 카드를 열람한 학생수는 총 2명이된다.
   
### #2
- 2번학생은 7번학생에게 카드를 전달하고 7번학생은 13번에게 13번학생은 6번에게 6번학생은 다시 13번에게 전달하게되지만 13번학생은 이미 이 카드를 열람했기때문에 횟수에서 제외
- 즉 2번학생에서 출발한 암기카드를 열람한 학생수는 총 4명이된다.

이런식으로 전달되어 열람된 카드의 가장 많은 열람횟수를 가진 카드의 가장 첫 시작학생번호를 리턴하는...이게맞나? 사실 기억에 의존해서 적다보니 좀 틀릴수도있을것같다.
  
대충 훑어본바로는 아마 재귀를 사용해서 풀어야만 하지않았을까 싶다. 자세한건 나중에 프로그래머스에 문제가 다시 올라오면 그때 시간을 좀 갖고 풀어볼 생각이다.
 
여기서 주의할점은 원래 인덱스는 0부터 시작하지만 학생번호가 0부터 있는경우는 없기때문에 1부터 시작한다고 볼 수 있다. 그리고 1번이 전달한 5번의 번호를 얻기위해서는 또 1이 아니라 인덱스값 0이 필요하게되서 코드를 짜다가 중간에 헷갈리거나 잊어버릴 요소가 다분해보인다.
  
```javascript
index + 1 => next_student[0] =>  next_student[next_student[0]]
```
대충 흐름만 보자면 저런식.... 그래서 재귀를 코드로 작성할 수 있느냐 없느냐를 확인하기위한 문제가 아니었을까 싶었다.

## ...
다음주는 4시간동안 과제를 푸는 테스트인데 실제 프로젝트를 하나 생성해놓고 문제를 해결하거나 추가 기능을 넣거나 하는 방식일것같다. 