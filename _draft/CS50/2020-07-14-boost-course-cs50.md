---
title: "부스트코스 - 모두를 위한 컴퓨터 과학 (CS50 2019) - 메모리"
categories: 
  -  boostcourse
tags: 
    - develop
    - study
    - edwith
    - boostcourse
    - cs50
    - C
    - 알고리즘
    - 메모리
toc: true
toc_sticky: true
comments:  true
---

## 메모리 주소
이전에 2진법과 10진법을 학습했었는데 이번에는 새로운 16진법을 학습한다. 10진법은 사람이 이해하기 쉬운 체계라면 2진법은 컴퓨터가 이해하기 쉬운 체계이다. 16진법은 중간다리 역할을 하면서 2진법보다는 간결하게 더 많은 데이터를 표현 할 수 있다.
```c
// 16진수
0 1 2 3 4 5 6 7 8 9 A B C D E F
// 10진수
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
// 2진수
00000000 00000001 00000010 00000011 00000100 00000101 00000110 ....
```

2진법 8비트로 표현할 수 있는 데이터는 255까지이고 더 많은 데이터를 표현하려면 비트의 수를 늘려야한다.
  

16진수는 1의 자릿수로 15까지 표현가능하며 15이상의 수를 나타내려면 16진수 하나를 추가하면된다.
```c
// 16진수 = 10진수
1 0 = 16 
```

하지만 위와같이 사용하게된다면 10진수인지 16진수인지 구분하기가 어렵다. 때문에 16진수에서는 모든 숫자앞에 0x 를 붙여 표현하여 16진수임을 나타낸다.  
```c
0x10
```
0x 는 사실상 수학적으로 아무런 의미는 갖지않지만 16진수와 10진수가 다르다는것을 구분하는데에는 아주 좋은 표현이 될것이다.

16진수를 사용하는 이유는 2진수에서 4비트가 16진수에서는 1자리로 맞아떨어지기 떄문이다. 4비트의 합은 15 즉 16진수에서는 F 로 표현할 수 있고 255 는 FF 로 표현이 가능하다.

```c
11111111 == FF == 255
128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 // 2진수
16 * 15 + 15 // 16진수
255 // 10진수
```

255는 웹개발을해봤거나 그래픽툴을 다뤄봤다면 어디선가 봤을 익숙한 숫자이기도한데 포토샵이나 웹개발에서 색상을 표현할때 RGB 라는 기준으로 사용하고 이걸 프로그래밍 언어에서 사용할때 16진수 방법으로 표현한다. 
```c
#FFFFFF
```

메모리와 16진수의 관계는 어떻길래 이 강의에 나오는지 확인해보도록 한다.

```c
#include <stdio.h>

int main(void) {
  int n = 50;
  printf("%i\n", n);
}
// result 50
```
위와같은 코드를 작성했을때 int 는 4바이트의 메모리 크기를가지기때문에 메모리를 시각화했을때
![메모리영역](https://i.ibb.co/Rbfh9GL/n.png)
이와같이 표현 할 수 있다. 메모리의영역 어딘가에 4바이트 영역을 50이라는 값이 차지하고있을거고 변수명은 n 으로 저장되어있을것이다.
  
이전에는 저장되어있는 변수값을 출력하였지만 C 에서는 메모리영역의 주소또한 출력이 가능하다.

```c
printf("%p\n", &n);
```
변수 n 의 주소를 출력하려면 & 를 붙여서 출력하면된다. 주소는 출력시마다 매번 달라지며 메모리영역을 초과하지않는이상 변수는 항상 메모리의 어딘가에 존재할것이고 그 저장된 메모리의 주소를 우리는 확인할 수 있다.

```c
0x7ffee86208dc
```
0x 가 붙는 메모리주소를 출력해주는것을보니 메모리의 주소를 16진수로 구성되어있는것을 알 수 있다. 이때 출력을 %i 가아닌 %p 로 출력했는데 이는 포인터를 사용하기 때문이다.  

포인터에 해당 메모리영역의 주소를 출력해달라고 할때 사용한다.

## 포인터
C에서 가장 개념잡고 이해하기가 어려운 포인터 부분이다. 사실 이 강의만 듣고서는 포인터에 대한 이해를 하기가 쉽지는 않은것같다. 설명은 쉽게 해주는데 응용해서 여기저기 사용하다보면 왜 여기서 포인터가 쓰이는지 잘 그림이 안그려질때가 있었다.
  
포인터는 변수가 저장된 메모리영역의 주소를 가르키는 역할을 한다. 포인터변수를 지정할떄는 변수명앞에 `*` 를 붙이고 주소를 출력하거나 주소를 저장할때는 값이 저장된 변수명앞에 `&` 를 사용한다. 

```c
#include <stdio.h>

int main(void) {
  int n = 50;
  int *p = &n;
}
```
먼저 정수형 n 이라는 변수명에 50이라는 값을 지정합니다.  
그리고 int 형 정수를 저장한 n 을 가르키는 포인터또한 같은형인 정수형 int 로 n 이 저장된 주소를 넘겨받습니다.

```c
printf("%p", p); // 포인터가 가르키고있는 변수의 주소를 출력
printf("%i", *p); // 포인터가 가르키고있는 변수의 주소의 변수값을 출력
```

이미 포인터를 사용하고있는 변수에 출력을 할때 다시 * 을 붙여주게되면 역참조라고해서 주소값이 아닌 원래 포인터가 가르키고있는 메모리의 변수값을 출력하게 됩니다.  

사실상 `*p` 는 n 의 주소값을 저장하고 있다고 볼 수 있지만 그냥 포인터는 값이 지정된 변수의 메모리를 가르키고있다 바라보고있다 라고 이해하고 사용하는것이 가장 좋습니다.

**check**  
```c
int main(void) {
  int n = 50;
  int *p = &n;
  printf("%p\n", p);
  printf("%p\n", &p);
}
```

위의 테스트는 과연 p 와 &p 의 주소값은 같을까? 라는 질문에서 시작해서 테스트하게되었는데  
일단 p 는 n 의 주소값을 바라보고있습니다. 때문에 p 는 n 의 주소값을 출력합니다.  

&p 는 그럼 n의 주소를 출력하는지 아니면 다른 주소값이 나오는지 궁금할 수 있는데 답만 얘기하자면 두 주소는 서로 다른 주소값을 출력합니다.  

이유는 p 또한 결국 변수이고 메모리의 어딘가에 영역을 차지하고 저장되어있을것입니다. 그렇다면 p 또한 별도의 메모리주소를 갖고있을것이고 p 와 &p 는 당연히 다른 주소값을 출력하게됩니다.

## 문자열
문자열은 각각 하나의 문자가 하나의 메모리영역 즉 1byte 를 차지하고있고 문자열자체가 하나의 배열이라고 배웠다. 그리고 문자열은 항상 문자열의 끝을 알려주기위해 종단문자인 null 을뜻하는 \0이 포함되어있기때문에 4글자의 문자열을 저장하였다면 사실은 5byte 의 메모리영역을 차지하고있다고 볼 수 있다.

```c
char name[5] = EMMA;
name[0] // E
name[1] // M
name[2] // M
name[3] // A
```

변수 name 에 EMMA 를 저장했다면 각각 접근해야 문자의 값을 출력 할 수 있고 접근 가능하다.

```c
int main(void) {
    char *name = "EMMA";
    printf("%p\n", name);
}
```
포인터를 사용하면 위와같이 사용 할 수 있고 여기서 포인터는 `EMMA` 에서 `E` 가 저장된 메모리 주소를 바라보고있고 나머지 뒤 문자열들은 출력된주소에 1씩 더해서 증가시켜주면 접근이 가능하다. 문자열자체가 하나의 배열이기때문에 연속된 메모리영역에 저장되어있고 첫번쨰 글자의 메모리주소만 알아낼 수 있으면 나머지 뒤의 문자들의 주소또한 알아낼 수 있고 접근이 가능하다.

- char *name = "EMMA" 는 EMMA 를 저장하고있는것이 아닌 문자열의 가장 첫번째 문자의 주소만 기억하고 있는것과 같다.



## 문자열 비교
```c
int main(void) {
    char *name = "EMMA";
    printf("%c\n", *name); // E
    printf("%c\n", *(name + 1)); // M
}
```
포인터를 활용하면 위와같이 문자열에서 각각의 문자에 접근이 가능하다.  

```c
printf("%s", name)
// result 
// EMMA
```
위와같이 사용하면 EMMA 를 다 출력하는데 이것은 `printf()` 함수 내부에서 동작하는 방식이고 %s 로 출력할경우 문자열에서 종단문자를 만나기전까지 문자열을 계속 출력하기때문이다.


**문자열의 비교**  
문자열의 비교를하려고 직접 만들어서 사용하던 get_string() 함수가 이번 강의를 통해서 잘못 작성된 함수라는것을 알았습니다. cs50 라이브러리에서 제공하는 get_string() 이 리턴해주는 데이터는 문자열의 첫번째 문자의 주소값을 리턴해주는데 내가만든건 주소값이 가장 마지막에 사용했던 get_string() 의 값이 들어가 이전값이 사라져버린다.

## 문자열 복사

## 메모리 할당과 해제

## 메모리 교환, 스택, 힙

## 파일 쓰기

## 파일 읽기