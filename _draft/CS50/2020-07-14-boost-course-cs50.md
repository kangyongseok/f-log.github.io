---
title: "부스트코스 - 모두를 위한 컴퓨터 과학 (CS50 2019) - 메모리"
categories: 
  -  boostcourse
tags: 
    - develop
    - study
    - edwith
    - boostcourse
    - cs50
    - C
    - 알고리즘
    - 메모리
toc: true
toc_sticky: true
comments:  true
---

## 16진수

```c
128 64 32 16 8 4 2 1 // 8비트 2진수
11111111 // 2진수 255 표현식
1111 1111
 F    F
 0xFF // 16진수

16 1 // 16진수
01 = 1
02 = 2
03 = 3
04 = 4
.
.
.
.
09 = 9
0A = 10
0B = 11
0C = 12
.
.
.
0F = 15
10 = 16 // 16진법의 '일 영' 이라고 읽는다
.
1F = 31
```

```c
// color RGB 는 16진법으로 표현
Red Green Blue
00   00    00 // 검정색
FF   00    00 // 빨간색
00   FF    00 // 녹색
00   00    FF // 파란색
FF   FF    FF // 흰색
```

하지만 이렇게 사용할경우 이게 2진수인지 10진수인지 구분하기 힘들수 있다. 그래서 16진수를 표현할때에는 모든 16진수앞에 `0x`를 붙인다.

```c
0 => 0x0
1 => 0x1
2 => 0x2
.
.
.
F => 0xF
.
.
1F => 0x1F
```

주로 메모리를 다룰때 사용하는데 왜 16진수를 사용하는지 그리고 어떻게 사용되는지 알아보자

```c
int n = 50
```
위의 변수 n 은 메모리의 어딘가에 4비트의 자리를 차지하고 있을것이다.  
이 변수가 저장되어있는 메모리의 주소를 출력하면 `0x `로 시작하는 16진수의 값을 출력해준다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n); // 변수 n이 저장되어있는 메모리의 주소(포인터)를 출력하는 문법
}
```

## CS50 을 16진수로
**1단계 10진수로 변환**  
```console
C => 67  
S => 83  
50 => 50 
``` 

**2단계 8bit 2진수로 변환**  
```console
67 => 01000011  
83 => 01010011  
50 => 00110010 
```

**3단계 2진수를 4비트씩 쪼갠 숫자**
```console
0100 0011 => 64 3  
0101 0011 => 80 3  
0011 0010 => 48 2  
```

**4단계 16진수로 변환**  
```console
64 3 => 43  
80 3 => 53  
48 2 => 32  
```


## 포인터
```c
int n = 50; // 변수 n 에 50을 저장
int *p = &n; // n의 주소를 p에 저장
```
여기서 p 는 n 의 주소를 실제로 저장하고있는것이 아닌 50을 가르키고 있다고 볼 수 있다. 

## 다시 문자열

```c
#include <stdio.h>

int main(void)
{
  char *s = "EMMA";
  printf("%c\n", *s); // 첫번쨰 주소 = 첫번째 문자열 "E"
  printf("%c\n", *(s + 1)) // 첫번째주소 + 1 = 두번째 문자열 "M"
}
```

## 메모리교환 스택, 힙

만약 서로 다른 음료가 들어있는 두컵이 있을때 이 두 음료를 서로 각각 다른 컵으로 바꿔 담고싶을때 어떻게 해야할까?  
주어진 조건이 이 두개의 컵만 있다면 아마 불가능할것이다 물리적으로는 그러나 만약 빈컵이 하나 더있다면? 아주 쉽게 두 컵의 내용물을 스위칭 가능할것이다.  

메모리에 저장되어있는 값을 이렇게 서로 스위칭 하려면 어떻게 해야할까?

```c
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
  int x = 1;
  int y = 2;

  printf("x is %i, y is %i\n", x, y);
  swap(x, y);
  printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
  int tmp = a;
  a = b;
  b = tmp;
}
```

위의코드를 실행하게되면 swap 함수가 정상 동작하지만 결과값은 전혀 바뀌지 않은것을 볼 수 있다. 문제가 무엇일까?   

바로 메모리에 저장된 값을 스위칭하는것이 아니라 복제된 값을 스위칭하기 때문이다. 즉 swap 함수가 실행되어도 본래 메모리에 저장된 x 와 y 의값이 바뀌진 않는다.  

a, b, x, y, tmp 모두 스텍 영역에 저장되지만 ab 와 xy는 서로 다른 위치에 저장된 변수일 뿐이다.
이 문제를 해결하려면 a와 b 가 x, y를 가리키는 포인터로 지정하게되면 값의 복사가 아닌 원래 저장되어있던 x와 y의 값을 스위칭 하는것이 가능하다.


```c
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
  int x = 1;
  int y = 2;

  printf("x is %i, y is %i\n", x, y);
  swap(&x, &y);
  printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
  int tmp = *a;
  *a = *b;
  *b = tmp;
}
```