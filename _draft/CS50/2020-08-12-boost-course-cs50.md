---
title: "부스트코스 - 모두를 위한 컴퓨터 과학 (CS50 2019) - 자료구조"
categories: 
  -  boostcourse
tags: 
    - develop
    - study
    - edwith
    - boostcourse
    - cs50
    - C
    - 알고리즘
    - 자료구조
toc: true
toc_sticky: true
comments:  true
---

## malloc 과 포인터 복습
```c
int main(void) {
  int *x; // x 는 포인터 변수로 주소를 저장 받을 수 있는 상태
  int *y;

  x = malloc(sizoeof(int)); // x 애 malloc 으로 int 의 사이즈 (4바이트) 만큼의 메모리 영역을 할당

  *x = 42; // 포인터변수 x 에 42라는 숫자를 할당
  *y = 30;
}
```

위 코드에서 버그가 존재하는데 x 는 malloc 으로 숫자값이 들어갈 메모리영역을 할당해 주었는데 y 는 별도로 할당해준 메모리가 없이 변수에 값을 넣었다. 이러한 경우 메모리문제나 컴파일에 따라 다른 버그가 발생할 수도있다.

```c
int main(void) {
  int *x; // x 는 포인터 변수로 주소를 저장 받을 수 있는 상태
  int *y;

  x = malloc(sizoeof(int)); // x 애 malloc 으로 int 의 사이즈 (4바이트) 만큼의 메모리 영역을 할당

  *x = 42; // 포인터변수 x 에 42라는 숫자를 할당
  
  y = x;

  *y = 13;
}
```

여기서는 y에도 정상적으로 메모리영역이 할당될것이다. 하지만 원래 x 에 들어가있던 변수값인 42는 사라지고 13이라는 새로운 값이 그자리를 차지하게 될것이다.  

즉 x 와 y 는 현재 같은 메모리 영역을 참조하고 있다고 볼 수 있다.



## 배열의 크기 조정하기

## 연결리스트: 도입
연결리스트는 값들의 리스트를 저장하는 방법이다. 배열도 동일한 값들의 리스트를 저장 할 수 있지만 배열에는 단점이 존재한다.  

배열은 고정된 메모리 덩어리로 배열의 크기를 조정해서 더 큰 데이터들을 넣어주려고 하면 더 많은 메모리를 할당해 주어야하고 기존의 배열에서 새로운 배열로 모든 값들을 복사해 와야만 한다. 때문에 배열에 새로운 값을 추가하는 작업은 O(n) 의 시간이 소요가 된다.  

배열의 장점으로는 인덱스로 원하는 위치에 한번에 접근이 가능하다.   

배열은 연속된 메모리영역에 차례로 값이 저장되어있는것이 배열이고 메모리에서도 순차적으로 값이 들어가 있다. 리스트는 비 순차적인 메모리영역 즉 랜덤한 메모리 영역에 무작위로 값이 저장되어 있는 상황이라면 이 값들을 연결해서 리스트로 만들어서 연속된 값으로 이어붙여 사용 할 수 있다. 

이를 위해 리스트는 실제 값이 저장될 영역과 다음 리스트의 메모리주소를 가리킬 포인터메모리영역이 필요하기때문에 최소 2칸의 메모리 영역이 필요하고 이를 정의하기위해 구조체를 사용할 수 있다.

### 노드 구조체를 정의하는 방법
```c
/*
연결리스트에서 노드를 추가하는 규칙
1. 노드에 메모리 할당
2. next 멤버에 다음 노드의 메모리 주소 저장
3. data 멤버에 데이터 저장
4. 마지막 노드라면 next 멤버에 NULL 저장
*/
typedef struct node { // node 는 구조체의 이름
  int number;
  struct node *next; // 노드의 구조체를 가리키도록 정의
}node; // 구조체의 별명

int main() {
  node *head = malloc(sizeof(struct node)); // 머리노드 기준점이기때문에 별도의 데이터를 
  저장하지는 않는다.

  node *node1 = malloc(sizeof(struct node)); // 실제 노드를 생성
  head->next = node1; // 머리노드에 next 에 첫번째 노드의 주소를 저장 (head 의 next 는 node1을 가르키고 있음)
  node1->data = 10; // node1 의 data 에 10을 저장

  node *node2 = malloc(sizeof(struct node)); // 실제 노드를 생성
  node1->next = node2;
  node2->data = 20;

  node2->next = NULL; // 두번째 노드 다음엔 노드가 없음

}
```

## 연결리스트: 코딩
```c
node *n = malloc(sizeof(node));
(*n).number = 2; // 이렇게 값을 할당해줘도 되지만
n->number = 2; // 이렇게 훨씬 보기좋게 사용이 가능하다.
n->next = NULL; // 다음값이 아직 없기때문에 NULL 로 입력한다.
```
좀더 정확하게 체크하기위해서 아래와 같은 코드로 작성할 수 있다.
```c
node *n = NULL;
node *n = malloc(sizeof(node));
if (n != NULL) { //
  n->number = 2;
  n->next = NULL;
}
list = n;
```

## 연결리스트: 시연


## 연결리스트: 트리

## 해시테이블

## 트라이

## 스택, 큐 딕셔너리