---
title: "부스트코스 - 모두를 위한 컴퓨터 과학 (CS50 2019) - 배열"
categories: 
  -  boostcourse
tags: 
    - develop
    - study
    - edwith
    - boostcourse
    - cs50
    - C
    - compile
toc: true
toc_sticky: true
comments:  true
---

## 컴파일링
```c
#include <stdio.h> // 누군가 이미 작성해둔 코드를 모아놓은 라이브러리

int main(void)
{
  printf("hello, world!\n");
}
```
컴파일링의 4단계
1. 전처리 - 라이브러리로 불러왔던 #으로 시작하는 구문을 실제 사용중인 함수를 정의한 코드로 불러오는 처리를 합니다.
2. 컴파일 - 컴파일이 진행되면 작성되었던 코드들은 어셈블리어로 치환된다.
3. 어셈블링 - 컴파일되어 어셈블리어로 변경된 코드를 다시 0 과 1로 이루어진 머신코드로 변경한다.
4. 링킹 - 이렇게 머신코드로 변경된 코드들은 # 으로 불러온 라이브러리와 직접 작성한 코드가 있는데 이 각각 작성되고 변환된 코드들을 하나로 연결해주는 작업을 하게 된다.

  
즉 컴파일이란 사용자가 작성한 코드들을 컴퓨터가 이해 할 수 있는 머신코드로 변경하고 합쳐지는 과정이고 이를 통해 사용자는 사용자 친화적인 코드로 프로그래밍을 할 수 있도 컴퓨터는 컴퓨터가 이해 할 수 있는 언어로 받아들일 수 있게 된다.

## 디버깅
코드를 작성하다보면 수많은 버그에 직면하게 된다.  버그란 의도하지않은 동작으로 인해 발생하는 에러 문제점 트러블이다. 그리고 이 문제를 해결하는 과정은 바로 디버깅 이라고 한다.  

개발자는 끊임없이 버그와 싸우고 어쩌면 코드를 작성하는것보다 버그와 씨름하는 시간이 더 많을수도있다. 내가 만들어낸 버그도 있겠지만 동료가 만든 버그가 있을수도있고 또 내가 다른 사람의 코드를 수정하다 버그가 발생할 수도있다. 이런떄 유용한 도구가 디버깅 도구들인데 cs50 에서는 sandbox 에서 help50 란 명령어로 명확한 디버깅 메세지를 출력해주는 도구를 제공한다.  

나는 vscode 컴파일 과정에서 발생하는 에러메세지를 보고 문제들을 해결하고 있다.  

다른 사람들과 스터디하는 과정에서 컴파일에 따라 에러를 출력하는 상황이 다른것을 알게 되었는데 아마 얼마나 컴파일과정에서 엄격하게 디버깅을 수행하느냐에따라 다른것같다.  

에러메세지는 대부분 영어로 나오기때문에 잘 모르겠다면 그냥 복붙으로 구글에 바로 검색한다. 대부분의경우 스택오버플로우에 내가 겪은 문제를 똑같인 겪고 글을 올리고 해결방법이 제시된 경우가 90%확률로 존재한다.  

코드를 작성하면서 `printf()` 로 결과를 확인해가면서 코드를 작성하는것도 디버깅이다. 디버깅이란 따로 어떤 특정 행위를 지칭하긴하지만 코드를작성하면서 확인과정을 거치는 모든것을 디버깅이라고 할 수 있겠다.
  

이 강의에서는 기존 sandbox 보다 좀더 효율적인 디버깅 도구들을 갖고있는 IDE 를 소개해주는데 CS50 IDE 라고 한다. 깃헙아이디로 로그인하고 바로 사용 가능한것같고 꽤 편안한 도구들을 많이 포함하고 있다. 그러나 난 역시 vscode를 계속 사용하기 때문에 날것 그대로의 에러 메세지를 보면서 강의과제와 실습을 진행하고 있다. 



## 코드의 디자인
코드에도 디자인이 필요하다. 코드컨벤션 이라고도 부르는데 일종의 코드를 작성하는 사람들끼리의 약속이다.  

이는 동일한 언어를 사용한다고 했을때 어느프로젝트 코드를 보든 일관성있게 코드를 읽어 나갈 수 있게 해주고 협업하는 과정에서도 동료간에 업무의 효율성과 버그의 발생 확률을 낮춰주는 역할을 할 수 있다.  

```c
#include <stdio.h>

int main(void) { // 중괄호를 여기서부터 사용할지
  printf("hello, world\n");
}

int main(void)
{ // 여기서부터 사용할지는 입사한 회사의 기준마다 다르다.
  printf("hello, world\n");
}

int main(void)
  {  // 이런식으로 작성한다면 심지어 이게 수백줄의 코드가 다 이렇다면 정말 괴롭다.
printf("hello, world\n");
  }
```

코드스타일은 우리가 문서를 작성할때 띄어쓰기와 문단나누기 그리고 들여쓰기 같은것과 동일하다. 규칙성있게 작성한다면 한달후 또는 몇년후에 내가 다시 봐도 충분히 봐줄만한 코드일것이다.  

c 에도 있을지 모르겠지만 javascript 같은경우 코드스타일을 일관성있게 작성하게 도와주는 도구가 존재한다. cs50에서도 styl50이라는 라이브러리로 기준 스타일에서 벗어나면 에러를 출력하는 도구를 제공한다.

### 고무오리 디버깅
누군가에게 내가 작성한 코드를 설명하는것은 매우 중요하다. 하지만 사람을 붙잡고 이런 설명을 하는것이 어려울수도 있다. 그래서 개발자들사이에서는 고무오리디버깅 이라는 디버깅 방법이 따로있다. 고무오리를 들고 내가 작성한 코드에 대해서 설명하는것이다. 피드백은 중요하지않다. 이 설명 과정에서 내가 빼먹은걸 발견하게 된다면 성공적인 디버깅이었고 성공적인 코드리뷰 였다고 할 수 있겠다.


## 배열(1)

## 배열(2)

## 문자열과 배열

## 문자열의 활용

## 명령행 인자





## 컴파일링
```c
#include <stdio.h>
#include <cs50.h>

int main(void)
{
    printf("hello, world!\n");
}
```

```terminal
$ clang -o hello hello.c -lcs50
or
$ make hello
```

지금까지 위와같은 형태로 계속 실습을 하면서 명령어를 통해 컴파일링을 하고 실행을 했었는제 저 명령어가 정확히 어떤 방식으로 동작하는지 생각해볼 필요성이 있다.  

처음강의에서 컴퓨터는 0과 1로만 이루어져있다고 했다. 그렇다면 c 에서 사용하는 소스코드와 명령어를 어떻게 컴퓨터는 받아들일까?  

```terminal
$ clang -o hello hello.c -lcs50
or
$ make hello
```

바로 이 컴파일 실행 명령어를 통해 작성한 소스코드는 어셈블리어로 대체되고 이 어셈블리어는 다시 0과 1로 이루어진 데이터로 변형된다. 그리고 `#include`로 불러와진 함수들의 모음을 가진 라이브러리 파일들도 함께 포함시켜 컴파일하면서 하나의 출력파일로 만들고 컴퓨터는 이를 읽어들일 수 있게된다.

## 문자열
문자열을 가진 변수들은 각각 메모리에 저장되는데 문자열같은경우 문자열이 끝났다 라는것을 구분하기위해 문자열 마지막에 항상 null 을 나타내는 0 이 포함된다.